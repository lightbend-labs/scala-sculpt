# Sculpt: dependency graph extraction for Scala

Sculpt is a compiler plugin for analyzing the dependency structure of
Scala source code.

The data generated by the plugin should be useful for all sorts of
refactoring efforts, including carving a monolithic codebase into
independent subprojects.

The plugin analyzes source code, not generated bytecode. The analysis
code resembles that used by the incremental compiler in sbt and zinc.
Therefore, the plugin should be an accurate source of information for
developers looking to reduce dependencies in order to reduce their
incremental recompile times.

## Building the plugin from source

`sbt package` will create `target/scala-2.11/scala-sculpt_2.11-0.1.0.jar`.

## Using the plugin

You can use the compiled plugin with the Scala 2.11 compiler as follows.

Supposing you have `scala-sculpt_2.11-0.1.0.jar` in your current working directory,
along with `spray-json_2.11-1.3.2.jar` (which you can download
[here](http://repo1.maven.org/maven2/io/spray/spray-json_2.11/1.3.2/spray-json_2.11-1.3.2.jar).

Then you can do e.g.:

    scalac -Xplugin:scala-sculpt_2.11-0.1.0.jar:spray-json_2.11-1.3.2.jar \
      -Xplugin-require:sculpt \
      -P:sculpt:out=dep.json \
      Dep.scala

## Sample input and output

Assuming `Dep.scala` contains this source code:

```
object Dep1 { final val x = 42 }
object Dep2 { val x = Dep1.x }
```

then the command line shown above will generate this `dep.json` file:

```
[
  {"sym": ["o:Dep1"], "extends": ["pkt:scala", "tp:AnyRef"]},
  {"sym": ["o:Dep1", "def:<init>"], "uses": ["o:Dep1"]},
  {"sym": ["o:Dep1", "def:<init>"], "uses": ["pkt:java", "pkt:lang", "cl:Object", "def:<init>"]},
  {"sym": ["o:Dep1", "def:x"], "uses": ["pkt:scala", "cl:Int"]},
  {"sym": ["o:Dep1", "t:x"], "uses": ["pkt:scala", "cl:Int"]},
  {"sym": ["o:Dep2"], "extends": ["pkt:scala", "tp:AnyRef"]},
  {"sym": ["o:Dep2", "def:<init>"], "uses": ["o:Dep2"]},
  {"sym": ["o:Dep2", "def:<init>"], "uses": ["pkt:java", "pkt:lang", "cl:Object", "def:<init>"]},
  {"sym": ["o:Dep2", "def:x"], "uses": ["o:Dep2", "t:x"]},
  {"sym": ["o:Dep2", "def:x"], "uses": ["pkt:scala", "cl:Int"]},
  {"sym": ["o:Dep2", "t:x"], "uses": ["pkt:scala", "cl:Int"]}
]
```

Each line in the JSON file represents an edge between two symbols in a
dependency graph.

The edges are of two types, `extends` and `uses`.

Each symbol is represented in the JSON as an array of strings, where
each string represents a part of the symbol's fully qualified name.

So for example, in the above source code, we see that `Dep1` extends
`scala.AnyRef`:

    {"sym": ["o:Dep1"], "extends": ["pkt:scala", "tp:AnyRef"]},

And we see that `Dep1` uses `scala.Int` in two places:

    {"sym": ["o:Dep1", "def:x"], "uses": ["pkt:scala", "cl:Int"]},
    {"sym": ["o:Dep1", "t:x"], "uses": ["pkt:scala", "cl:Int"]},

from this we see that `scala.Int` is used as the declared return type
of `Dep1.x`, and as the inferred type of the body of `Dep1.x`.

For brevity, the following abbreviations are used in the JSON output:

### Terms

abbreviation | meaning
-------------|--------
ov           | object
def          | def
var          | var
mac          | macro
pk           | package
t            | other term

### Types

abbreviation | meaning
-------------|--------
tr           | trait
pkt          | package
o            | object
cl           | class
tp           | other type

### Other

The name of a constructor is always `<init>`.

## Graphs represented as case classes

The same JAR that contains the plugin also contains a suite of case
classes for representing the same information in the JSON files as
Scala objects.

We provide a `load` method for parsing a JSON file into instances
of these case classes, and a `save` method for writing the instances
back out to JSON.

These classes provide a possible starting point for graph analysis and
manipulation, e.g. in the REPL.

### Sample interactive session

Now in a Scala 2.11 REPL with the same JARs on the classpath:

    scala -classpath scala-sculpt_2.11-0.1.0.jar:spray-json_2.11-1.3.2.jar

If we load `dep.json` as follows, we'll see the following graph:

```
scala> import scala.tools.sculpt.cmd._
import scala.tools.sculpt.cmd._

scala> load("dep.json")
res0: scala.tools.sculpt.model.Graph = Graph 'dep.json': 11 nodes, 11 edges

scala> println(res0.fullString)
Graph 'dep.json': 11 nodes, 11 edges
Nodes:
  - o:Dep1
  - pkt:scala.tp:AnyRef
  - o:Dep1.def:<init>
  - pkt:java.pkt:lang.cl:Object.def:<init>
  - o:Dep1.def:x
  - pkt:scala.cl:Int
  - o:Dep1.t:x
  - o:Dep2
  - o:Dep2.def:<init>
  - o:Dep2.def:x
  - o:Dep2.t:x
Edges:
  - o:Dep1 -[Extends]-> pkt:scala.tp:AnyRef
  - o:Dep1.def:<init> -[Uses]-> o:Dep1
  - o:Dep1.def:<init> -[Uses]-> pkt:java.pkt:lang.cl:Object.def:<init>
  - o:Dep1.def:x -[Uses]-> pkt:scala.cl:Int
  - o:Dep1.t:x -[Uses]-> pkt:scala.cl:Int
  - o:Dep2 -[Extends]-> pkt:scala.tp:AnyRef
  - o:Dep2.def:<init> -[Uses]-> o:Dep2
  - o:Dep2.def:<init> -[Uses]-> pkt:java.pkt:lang.cl:Object.def:<init>
  - o:Dep2.def:x -[Uses]-> o:Dep2.t:x
  - o:Dep2.def:x -[Uses]-> pkt:scala.cl:Int
  - o:Dep2.t:x -[Uses]-> pkt:scala.cl:Int
```

and we can explore the effect of removing edges from the graph using `removePaths`:

```
scala> res0.removePaths("Dep2", "java.lang")

scala> println(res0.fullString)
Graph 'dep.json': 6 nodes, 4 edges
Nodes:
  - o:Dep1
  - pkt:scala.tp:AnyRef
  - o:Dep1.def:<init>
  - o:Dep1.def:x
  - pkt:scala.cl:Int
  - o:Dep1.t:x
Edges:
  - o:Dep1 -[Extends]-> pkt:scala.tp:AnyRef
  - o:Dep1.def:<init> -[Uses]-> o:Dep1
  - o:Dep1.def:x -[Uses]-> pkt:scala.cl:Int
  - o:Dep1.t:x -[Uses]-> pkt:scala.cl:Int
```

Saving the graph back to a JSON model and loading it again:

```
scala> save(res0, "dep2.json")

scala> load("dep2.json")
res5: scala.tools.sculpt.model.Graph = Graph 'dep2.json': 3 nodes, 2 edges

scala> println(res5.fullString)
Graph 'dep2.json': 6 nodes, 4 edges
Nodes:
  - o:Dep1
  - pkt:scala.tp:AnyRef
  - o:Dep1.def:<init>
  - o:Dep1.def:x
  - pkt:scala.cl:Int
  - o:Dep1.t:x
Edges:
  - o:Dep1 -[Extends]-> pkt:scala.tp:AnyRef
  - o:Dep1.def:<init> -[Uses]-> o:Dep1
  - o:Dep1.def:x -[Uses]-> pkt:scala.cl:Int
  - o:Dep1.t:x -[Uses]-> pkt:scala.cl:Int
```

## Future work

Possible future directions include:

* user interface, e.g. via ScalaIDE integration
* aggregation of dependency data at different "zoom levels" (per-package, per-file, per-class/trait/object, per-method)
* identify layers and cycles
* automatic identification of problematic dependencies
* “what-if” analyses exploring the effect of proposed code changes
* offer a means of declaring and enforcing desired architectural constraints (allowed and forbidden dependencies)
