# Sculpt: dependency graph extraction for Scala

Sculpt is a compiler plugin for analyzing the dependency structure of
Scala source code.

The data generated by the plugin should be useful for all sorts of
refactoring efforts, including carving a monolithic codebase into
independent subprojects.

The plugin analyzes source code, not generated bytecode. The analysis
code is the same code used by the incremental compiler in sbt and zinc
([reference](https://github.com/gkossakowski/sbt/wiki/Incremental-compiler-notes#dependency-extraction)).
Therefore, the plugin should be an accurate source of information for
developers looking to reduce dependencies in order to reduce their
incremental recompile times.

## Building the plugin from source

`sbt package` will create `target/scala-2.11/scala-sculpt_2.11-0.1.0.jar`.

## Using the plugin

You can use the compiled plugin with the Scala 2.11 compiler as follows.

Supposing you have `scala-sculpt_2.11-0.1.0.jar` in your current working directory,
along with `spray-json_2.11-1.3.2.jar` (which you can download
[here](http://repo1.maven.org/maven2/io/spray/spray-json_2.11/1.3.2/spray-json_2.11-1.3.2.jar).

Then you can do e.g.:

    scalac -Xplugin:scala-sculpt_2.11-0.1.0.jar:spray-json_2.11-1.3.2.jar \
      -Xplugin-require:sculpt \
      -P:sculpt:out=dep.json \
      Dep.scala

## Sample input and output

Assuming `Dep.scala` contains this source code:

```
object Dep1 { final val x = 42 }
object Dep2 { val x = Dep1.x }
```

then the command line shown above will generate this `dep.json` file:

```
[
  {"sym": ["o:Dep1"], "extends": ["pkt:scala", "tp:AnyRef"]},
  {"sym": ["o:Dep1", "def:<init>"], "uses": ["o:Dep1"]},
  {"sym": ["o:Dep1", "def:<init>"], "uses": ["pkt:java", "pkt:lang", "cl:Object", "def:<init>"]},
  {"sym": ["o:Dep1", "def:x"], "uses": ["pkt:scala", "cl:Int"]},
  {"sym": ["o:Dep1", "t:x"], "uses": ["pkt:scala", "cl:Int"]},
  {"sym": ["o:Dep2"], "extends": ["pkt:scala", "tp:AnyRef"]},
  {"sym": ["o:Dep2", "def:<init>"], "uses": ["o:Dep2"]},
  {"sym": ["o:Dep2", "def:<init>"], "uses": ["pkt:java", "pkt:lang", "cl:Object", "def:<init>"]},
  {"sym": ["o:Dep2", "def:x"], "uses": ["o:Dep2", "t:x"]},
  {"sym": ["o:Dep2", "def:x"], "uses": ["pkt:scala", "cl:Int"]},
  {"sym": ["o:Dep2", "t:x"], "uses": ["pkt:scala", "cl:Int"]}
]
```

Each line in the JSON file represents an edge between two symbols in a
dependency graph.

The edges are of two types, `extends` and `uses`.

Each symbol is represented in the JSON as an array of strings, where
each string represents a part of the symbol's fully qualified name.

So for example, in the above source code, we see that `Dep1` extends
`scala.AnyRef`:

    {"sym": ["o:Dep1"], "extends": ["pkt:scala", "tp:AnyRef"]},

And we see that `Dep1` uses `scala.Int` in two places:

    {"sym": ["o:Dep1", "def:x"], "uses": ["pkt:scala", "cl:Int"]},
    {"sym": ["o:Dep1", "t:x"], "uses": ["pkt:scala", "cl:Int"]},

from this we see that `scala.Int` is used as the declared return type
of `Dep1.x`, and as the inferred type of the body of `Dep1.x`.

For brevity, the following abbreviations are used in the JSON output:

### Terms

abbreviation | meaning
-------------|--------
ov           | object
def          | def
var          | var
mac          | macro
pk           | package
t            | other term

### Types

abbreviation | meaning
-------------|--------
tr           | trait
pkt          | package
o            | object
cl           | class
tp           | other type

### Other

The name of a constructor is always `<init>`.

## Graphs represented as case classes

The same JAR that contains the plugin also contains a suite of case
classes for representing the same information in the JSON files as
Scala objects.

We provide a `load` method for parsing a JSON file into instances
of these case classes, and a `save` method for writing the instances
back out to JSON.

These classes provide a possible starting point for graph analysis and
manipulation, e.g. in the REPL.

### Sample interactive session

Now in a Scala 2.11 REPL with the same JARs on the classpath:

    scala -classpath scala-sculpt_2.11-0.1.0.jar:spray-json_2.11-1.3.2.jar

If we load `dep.json` as follows, we'll see the following graph:

```
scala> import scala.tools.sculpt.cmd._
import scala.tools.sculpt.cmd._

scala> load("dep.json")
res0: scala.tools.sculpt.model.Graph = Graph 'dep.json': 11 nodes, 11 edges

scala> println(res0.fullString)
Graph 'dep.json': 11 nodes, 11 edges
Nodes:
  - o:Dep1
  - pkt:scala.tp:AnyRef
  - o:Dep1.def:<init>
  - pkt:java.pkt:lang.cl:Object.def:<init>
  - o:Dep1.def:x
  - pkt:scala.cl:Int
  - o:Dep1.t:x
  - o:Dep2
  - o:Dep2.def:<init>
  - o:Dep2.def:x
  - o:Dep2.t:x
Edges:
  - o:Dep1 -[Extends]-> pkt:scala.tp:AnyRef
  - o:Dep1.def:<init> -[Uses]-> o:Dep1
  - o:Dep1.def:<init> -[Uses]-> pkt:java.pkt:lang.cl:Object.def:<init>
  - o:Dep1.def:x -[Uses]-> pkt:scala.cl:Int
  - o:Dep1.t:x -[Uses]-> pkt:scala.cl:Int
  - o:Dep2 -[Extends]-> pkt:scala.tp:AnyRef
  - o:Dep2.def:<init> -[Uses]-> o:Dep2
  - o:Dep2.def:<init> -[Uses]-> pkt:java.pkt:lang.cl:Object.def:<init>
  - o:Dep2.def:x -[Uses]-> o:Dep2.t:x
  - o:Dep2.def:x -[Uses]-> pkt:scala.cl:Int
  - o:Dep2.t:x -[Uses]-> pkt:scala.cl:Int
```

and we can explore the effect of removing edges from the graph using `removePaths`:

```
scala> res0.removePaths("Dep2", "java.lang")

scala> println(res0.fullString)
Graph 'dep.json': 6 nodes, 4 edges
Nodes:
  - o:Dep1
  - pkt:scala.tp:AnyRef
  - o:Dep1.def:<init>
  - o:Dep1.def:x
  - pkt:scala.cl:Int
  - o:Dep1.t:x
Edges:
  - o:Dep1 -[Extends]-> pkt:scala.tp:AnyRef
  - o:Dep1.def:<init> -[Uses]-> o:Dep1
  - o:Dep1.def:x -[Uses]-> pkt:scala.cl:Int
  - o:Dep1.t:x -[Uses]-> pkt:scala.cl:Int
```

Saving the graph back to a JSON model and loading it again:

```
scala> save(res0, "dep2.json")

scala> load("dep2.json")
res5: scala.tools.sculpt.model.Graph = Graph 'dep2.json': 3 nodes, 2 edges

scala> println(res5.fullString)
Graph 'dep2.json': 6 nodes, 4 edges
Nodes:
  - o:Dep1
  - pkt:scala.tp:AnyRef
  - o:Dep1.def:<init>
  - o:Dep1.def:x
  - pkt:scala.cl:Int
  - o:Dep1.t:x
Edges:
  - o:Dep1 -[Extends]-> pkt:scala.tp:AnyRef
  - o:Dep1.def:<init> -[Uses]-> o:Dep1
  - o:Dep1.def:x -[Uses]-> pkt:scala.cl:Int
  - o:Dep1.t:x -[Uses]-> pkt:scala.cl:Int
```

## Future work

Possible future directions include:

* user interface, e.g. via ScalaIDE integration
* aggregation of dependency data at different "zoom levels" (per-package, per-file, per-class/trait/object, per-method)
* identify layers and cycles
* automatic identification of problematic dependencies
* “what-if” analyses exploring the effect of proposed code changes
* offer a means of declaring and enforcing desired architectural constraints (allowed and forbidden dependencies)
